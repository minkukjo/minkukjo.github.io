---
layout: post
title: Script - Dockerfile
subtitle: ""
categories: script
tags: script
comments: false
---

## Script - Dockerfile

Dockerfile, Jenkinsfile, Ansible, makefile의 공통점은 무엇일까?

바로 Build를 위한 Script라는 점이다!

지금부터 하나씩 살펴보도록 하자.

## Dockerfile

![Docker-Dockerfiles](https://user-images.githubusercontent.com/43809168/78543279-66b49f80-7833-11ea-941b-aea15a2ae641.jpg)

도커는 `Dockerfile`의 명령에 따라 이미지를 자동으로 만들 수 있다.

`Dockerfile`은 사용자가 커맨드 라인으로 호출하는 명령어들을 포함하는 문서이다.

## 사용법

`Dockerfile`에 설정된 내용에 따라 이미지를 생성한다.

여러가지 명령어를 토대로 기본 이미지에서 개발 환경을 셋팅한 이미지를 생성할 수 있다.

`docker build` 명령어는 `Dockerfile`과 `Context`로부터 이미지를 만들어낸다.

`Context`는 구체적인 `PATH` or `URL`에있는 파일의 집합이다.

`PATH`는 로컬 파일 시스템에서 디렉토리를 의미하며, `URL`은 깃 레포지토리 주소를 의미한다.

`Context`는 재귀적으로 호출되어지는데, `PATH`는 하위 디렉토리가 포함되며 `URL`에는 저장소 및 해당 하위 모듈이 포함된다.

```
$ docker build .
Sending build context to Docker daemon 6.51 MB
...
```

이 빌드는 도커 데몬에서 실행된다. 빌드가 시작되고 가장 처음 시작되는 작업은 전체 `Context`를 데몬으로 보내는 것이다.

공식문서에 따르면 대부분의 경우에서는 빈 디렉토리를 `Context`로 시작하고 그 디렉토리에 `Dockerfile`을 위치시키고 빌드에 필요한 파일만 추가하는 것을 권장하고 있다.

`Dockerfile`은 `Build Context`에서 파일을 사용하기 위해 `COPY`와 같은 구체적인 명렁어들을 제공해준다.

그리고 빌드 성능을 높이기 위해 `Context Directory`에 `.dockerignore`을 추가함으로써 파일이나 폴더를 제외할 수 있다고 한다.

일반적으로 도커파일은 `Context`의 루트에 위치되어진다.

`-f` 태그를 사용하면 `docker build`할 때 `Dockerfile`의 명시적인 위치를 지정해주는 것이 가능하다고 한다.

```
$ docker build -f /path/to/a/Dockerfile .
```

또한 `-t` 태그를 사용하여 빌드가 성공하면 새로운 이미지를 저장할 저장소와 태그를 지정할 수 있다.

`$ docker build -t shykes/myapp .`

빌드 후 여러 저장소에 이미지를 태그하려면 `-t`를 여러번 파라미터로 줘서 빌드할 수 있다.

```
$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .
```

도커 데몬은 `Dockerfile`에 명령어를 실행하기 전에 `Dockerfile`의 예비 검증을 수행하고 만약 구문이 잘못되었다면 에러를 반환한다.

```
$ docker build -t test/myapp .
Sending build context to Docker daemon 2.048 kB
Error response from daemon: Unknown instruction: RUNCMD
```

도커 데몬은 `Dockerfile`의 명령어를 하나 하나 실행하고 필요한 경우 각 명령의 결과를 이미지에 반영한다.

**중요한 점**은 각 명령들은 독립적으로 수행하면서 새로운 이미지를 만들어내기 때문에 `Run cd /tmp`같은 명령들이 다음 명령에 영향을 미치지 않는다.

또한 가능하다면 도커는 **중간 이미지**를 캐싱해놓고 재사용하여 `docker build` 프로세스의 성능을 크게 가속화한다.

빌드 캐쉬는 로컬 상위 체인이 있는 이미지에만 사용된다.

## Format

도커 명령어의 포멧은 다음과 같다.

```dockerfile
INSTRUCTION arguments
```

명령은 대소문자를 구분하지는 않는다.

그러나 일반적으로는 명령은 대문자로 하는 것이 `국룰`이라고 한다.

도커는 `Dockerfile`의 명령어를 순차적으로 수행한다.

그리고 `Dockerfile`은 **반드시** `FROM` **명령어와 함께 시작되어야만 한다.**

`FROM` 명령어는 부모 이미지를 지정한다.

`FROM` 앞에는 하나 또는 그 이상의 `ARG` 명령만 존재할 수 있다.

`ARG`는 `Dockerfile`의 `FROM`에서 사용되는 인수를 선언할 수 있다.

가장 앞에 `#`이 오면 주석이고, 다른 곳에서는 인수로 취급된다.

```dockerfile
# Comment
RUN echo 'we are running some # of cool things'
```

위에서 `#`은 주석이며 echo 이후에 오는 `#`은 `argument`이다.

## Parser Directives

파서 지시문은 `Dockerfile`의 다음 줄에 영향을 줄 수 있는 옵션이다.

파서 지시문은 일반적으로 `# directive = value`와 같은 특수한 유형의 주석으로 작성된다.

또한 파서 지시문은 빌드에 레이어를 추가하지않으며, 빌드 단계에 표시되지 않는다.

빈줄이나 빌더 명령어가 실행되면 도커는 더 이상 `Parser Directives`를 찾지 않는다.

그러므로 모든 `Parser Directives`는 `Dockerfile`의 최상단에 위치시키는 것이 일반적이다.

`Parser Directives`는 대소문자를 구분하지는 않지만, 일반적으로는 소문자로 작성되는 컨벤션을 갖고 있다.

## Reference

https://docs.docker.com/engine/reference/builder/
