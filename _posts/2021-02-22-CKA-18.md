---
layout: post
title: CKA 공부 17일차
subtitle: ''
categories: devops
tags: k8s
comments: false
---

## TLS Basics

- 유저가 로그인 하려고 할 때 네트워크로 전송되는 유저의 정보는 중간에 가로챌 가능성이 반드시 존재한다.

- `http` 프로토콜에서 사용자가 로그인 할 때 유저 정보와 비밀번호를 평문으로 전달하면 해커가 쉽게 탈취해버릴 수 있다.

## Symetric Encryption

- 이를 막기 위해 유저 정보를 `encrypt`하게 되는데, 이렇게 하면 해커가 유저 정보를 볼 수 없지만 서버 역시 `key` 없이는 `decrypt`할 수 없게 된다.

- 이 `key`를 네트웤르르 통해 서버로 보내지만, 이 역시 해커가 중간에 가로챌 수 있으므로 여전히 위험하다.

## Asymetric Encryption

- 이를 위해 등장한 것이 `Asymetric Encryption`이며, 한국말로 비대칭 암호화라고 부른다.
  
- `Private key`와 `Public Key`로 구성되며, 여기서는 쉽게 `Private Key`, `Public Lock이`라고 부른다.

- Key는 오직 나만이 가지며, Lock은 누구나 접근할 수 있다.

- 유저 정보를 `Lock`을 사용해 암호화 하고, `Key`는 `Lock`으로 Encrypt된 데이터를 Decrypt할 수 있다.

## 웹 서버에서의 암호화 과정

- 웹서버에 비유해보자면, 서버측에서 먼저 비대칭 키를 생성한다. 

- 여기서 생성된 `Public Lock`을 유저에게 전달해준다.

- 유저는 자신이 가진 `Private Key`(대칭키)를 서버에서 전달받은 `Public Lock`와 함께 `Encrypt`한 후 서버로 넘긴다.

- 해커다 중간에 가로채긴 하지만, 해커가 가진 것은 서버의 `Public Lock`과 `Public Lock`으로 암호화된 유저의 대칭키 뿐이다.

- 이 정보를 `Decrypt` 하기 위해서는 서버의 `Private Key`가 필요한데, 해커는 이를 `Decrypt`할 수 없다.

- 서버는 `Public Lock`으로 암호화된 유저의 대칭키를 서버의 `Private Key`(비대칭 키)로 `Decrypt`하여 유저의 대칭키를 얻어낸다.

- 그 후 유저는 계속해서 유저의 정보를 대칭키로 암호화하고 전달하는데, 서버는 이미 갖고 있는 유저의 대칭키로 정보를 `Decrypt`한다.

- 하지만 해커는 유저의 대칭키를 얻어내지 못했으므로 정보를 `Decrypt`하지 못한다.

## 해커의 개수작

- 해커는 웹서버와 아주 유사한(사실은 거의 동일한) UI의 웹사이트를 만들고, 자신만의 비대칭키를 만들어두고 유저가 로그인하게 유인한다.

- 유저입장에서는 `https`로 접근하니 보안에 안전할 것이라 착각하지만, 해당 정보는 해커의 서버로 넘어가게 된다.

- 이를 위해 서버는 `Public Lock`을 유저에게 전달할 때 `Lock`만 전달하지는 않는다.

- `Certificate`라는 인증서와 함께 전달한다.

- 이 인증서는 해당 서버가 안전하다는 것을 보장해주는 인증서이다.

- 브라우저에서는 이러한 인증서가 유효하지않을 경우 사용자에게 경고를 내서 알려준다.

- 그것이 우리가 종종 웹서핑을 하다가 만나게 되는 `보안에 취약한 사이트입니다!`라는 식의 웹페이지이다.

- 당연히 해커가 만든 인증서는 해커가 사인을 했을 것이므로 안전하지 않다는 것을 쉽게 알아차릴 수 있다.

- 그러면 누가 이 인증서가 유효하다는 것을 인증해줄까?

- 이를 위한 CA 그룹이 있는데, 여기서 그들이 사인해준 인증서는 안전하다는 것을 보장할 수 있다.

- 그러면 해커가 CA에 인증서를 요청하면 되지 않냐고 하겠지만 이는 불가능하다.

- 왜냐하면 CA에서는 꼼꼼하게 요청자가 해당 웹사이트의 진정한 주인인지를 매우 엄격하게 심사한다고 한다.

- CA 기관들은 각자 자신들만의 `Private Key`와 `Public Lock`을 갖는다.

- `Public Lock`들은 모두 브라우저안에 내장되어 있으며, 브라우저는 CA의 `Public Lock`을 통해 CA가 검증한 인증서인지를 검증한다.

## CA와 함께 춤을

- 그러면 CA와 함께 HTTPS 인증을 위해 `Certificate`(인증서)를 주고 받는 과정을 이해해보자.

- 먼저 관리자가 비대칭 키를 생성하고 `Public Lock`을 서버에 전달한다.

- 서버 역시 비대칭키를 만든다. 

- 서버는 자신이 만든 `Public Lock`을 `CA`에 전달한다.

- `CA`에서는 서버로부터 `Public Lock`을 전달받은 후 CA의 `Private Key`로 `Encrypt`된 `Certificate`를 서버로 다시 돌려준다.

- 모든 유저(브라우저)들은 CA의 `Public Lock`을 가지고 있다는 것을 기억하자.

- 유저가 서버에 액세스할 때 마다 서버는 이 `Certificate`를 유저에게 전달해준다.

- 유저의 브라우저는 이 CA 인증서를 브라우저가 가진 `Public Lock`으로 `Decrpyt`하여 얻은 서버의 `Public Lock`으로 유저가 만든 대칭키를 `Encrypt`한다.
 
- 이렇게 `Encrypt`된 유저의 대칭키는 서버로 보내지고, 서버는 자신이 가진 `Private Key`로 유저의 대칭키(`Private Key`)를 얻어낸다.

- 유저는 일반적으로 `Certificate`를 만들지 않는다. 이는 일반적인 경우가 아니며 기본적으로 인증서에 대한 정보는 서버와 CA 기관이 만든다.

- 유저는 브라우저의 `Public Lock`으로 서버의 인증서로부터 `Public Lock`을 얻어낸 후 서버에 전달해준다.

- 그리고 나서 유저는 자신의 `Private Key`로 데이터를 암호화하고, 서버는 얻어낸 유저의 `Private Key`로 데이터를 복호화하여 사용한다. 이것이 우리가 잘 알고 있는 HTTPS이다.

- 참고로 위에서 `Public Lock`이라고 하였지만 실제로는 `Public Key`와 `Private Key`이다.

- 그러므로 `Certificate` 역시 인증서라고는 하지만, `Public Key`라고 봐도 무방하다.



