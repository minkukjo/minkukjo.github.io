---
layout: post
title: The Go Programming Language 1~2장
subtitle: ""
categories: go
tags: go
comments: false
---

## 책이 생기다.

![고 책](https://user-images.githubusercontent.com/43809168/77648688-e5941780-6fab-11ea-9afc-bd23dfe46e89.jpeg)

새롭게 맡게될 프로젝트가 Go 언어로 작성되어 있어서 멘토님이 책 주문하실 때 내것도 사주셨다.

겸사겸사 회사 구경도 하고 아주 재밌었다.

생각해보니 카카오 개발자들은 정말 대단하다고 느꼈다.

새로운 언어, 플랫폼을 사용하는 것을 주저하지 않고 배우고 적용한다.

가히 개발자들의 천국이라고 할만 하다.

물론 T자형 인재가 되기 위해서는 하나 정도는 나만의 전문적인 기술을 가져야하고, 그래서 Spring 공부도 꾸준히 하고 있지만 새로운 언어나 플랫폼을 공부하는 것은 늘 새롭고 즐거운 일이다.

이제부터는 이 책을 읽으며 기존에 몰랐던 사실들을 기록할 생각이다.

## Go에 대해 몰랐던 사실들

- string은 자바와 마찬가지로 `+=` 연산을 하면 새로운 문자열을 생성한다.

- 문자열이 빈번하게 생성될 경우 기존 문자열들이 가비지 컬렉터 대상이 되므로 성능에 영향을 끼칠 수 있다.

- 이를 위해 string 패키지에서는 `Join`이라는 메소드를 제공한다.

- 변수의 수명은 **해당 변수에 접근할 수 있는지 여부**로만 결정되기 때문에 지역 변수가 탈출했는지 여부를 잘 검사해야한다.

- 가령 전역 변수와 같이 수명이 긴 변수가 수명이 짧은 변수의 포인터를 유지하면 가비지 컬렉터가 이 변수의 메모리를 회수할 수 없게 된다.

- Go에는 전위 증감 연산자가 없으며, 후위 증감 연산을 변수의 대입에 사용할 수 없다.

```go
var a = b++ // Error!
++a // Error!
```

- 튜플 할당을 사용해 swap을 쉽게 구현할 수 있다. (마치 파이썬처럼)

```go
x,y = 5,10
y,x = x,y
fmt.Println(x,y)
// 출력 : 10 5
```

- 어떻게 이것이 가능할까 궁금해서 검색해보니까 stackoverflow에 이런 글이 있더라

https://stackoverflow.com/questions/35707222/swap-two-numbers-golang/35707958

- 내용은 대충 CPU가 메모리의 기존 값을 덮어 쓰지 않게 레지스터를 이용하여 구현 가능하다고 한다.

- 답변자는 링커가 기계 코드로 변환한 어셈블리 코드를 까서 확인하였는데 아래와 같다.

```c
0x0028 00040 (swap.go:10)   MOVQ    $10, CX         ; var a = 10
0x002f 00047 (swap.go:10)   MOVQ    $5, AX          ; var b = 5
0x0036 00054 (swap.go:11)   MOVQ    CX, "".b+16(SP) ; copy a to *b+16
0x003b 00059 (swap.go:11)   MOVQ    AX, "".a+24(SP) ; copy b to *a+24
```

- CX, AX같은 레지스터를 이용해 값을 저장해놓고 실제 값에 반영하는 것으로 보인다.

- 굉장히 똑똑한 방법으로 처리하는구나~ 라는 생각을 하게 되었다.

- 타입 캐스팅은 다음과 같이 가능하다 T(x), T는 변환할 타입 x는 변환 대상

- 패키지는 `init()` 함수를 사용해서 프로그램이 시작할 때 각 파일 내의 init 함수들이 선언된 순서대로 자동으로 실행된다.

## Reference

The Go Programming Language - 앨런 도노반, 브라이언 커니건 지음, 이승 옮김, 공용준 감수
