---
layout: post
title: CKA 공부 2일차
subtitle: ''
categories: devops
tags: k8s
comments: false
---

## ETCD

새벽에 잠 안와서 공부 고고.

## ETCD란

- 노드, 파드, 시크릿, 컨피그, 어카운트, 롤, 바인딩, 그외 등등에 관한 데이터를 저장하는 저장소

- 사용자는 이 정보들을 업데이트할 수 있는데, 업데이트 된 후에만 완료된 것으로 간주한다.

- 마스터 노드가 여러 개인 경우 각각의 노드에 대해 ETCD 인스턴스를 정의해주어야한다.

## kube-api-server

- 클라이언트가 요청하는 kubectl 명령어를 받아주는 곳

- 사용자가 파드 생성을 요청했을 때의 시나리오

1. kube-api-server가 해당 요청이 인증된 요청인지를 먼저 확인한다.

2. 스케쥴러는 kube-api-server를 모니터링하다가 노드가 할당되지 않은 새로운 파드가 생성된 것을 알아차리고 새로운 파드가 위치할 노드를 kube-api-server에게 알려준다.

3. kube-api-server는 ETCD 클러스터에 정보를 업데이트하고 스케쥴러가 지정해준 노드의 kubelet에게 파드를 생성할 것을 명령한다.

4. kubelet은 컨테이너 런타임에게 application image를 배포할 것을 지시한다.

5. 끝나면 kubelet은 다시 api-server에게 업데이트된 상태를 전송하고 api-server는 해당 내용을 다시 ETCD에 업데이트한다.

- kube-api-server는 ETCD와 통신하는 유일한 컴포넌트다.

## Controllers

- 컨트롤러는 마스터 노드에 위치하며 쿠버네티스 안의 오브젝트에 일어나는 여러 현상들을 감시하고 행동하는 오브젝트다.

- 가령 노드 컨트롤러의 경우 노드의 상태를 모니터링할 책임을 가지며 애플리케이션이 지속적으로 동작할 수 있게 하기 위한 행동을 취한다.

- node 컨트롤러는 kube-api-server를 통해 노드의 상태를 감시한다.

- 노드를 5초마다 감시한다.

- 응답하지 않는 노드를 마킹하는데, 마킹하기 전에 일단 40초 정도 기다려본다.

- 일단 노드를 마킹하면 다시 5분을 준다. 만약 그래도 응답 안하면 노드 안의 파드를 모두 지우고 다른 노드에 배치시켜준다.

- 컨트롤러는 노드 컨트롤러 외에도 굉장히 많은 컨트롤러들이 있는데 컨셉은 다 비슷하다.

- 이 컨트롤러들은 kube-controller-manager라고 하는 단일 프로세스 안에 패키징되어있다.

## kube-scheduler

- 스케쥴러는 단순히 이 파드가 어느 노드에 위치할 것인지 만을 결정해준다. 직접 옮기는 역할을 하지 않음.

- 스케쥴러는 어떻게 파드를 노드에 옮길까?
  - 후보 파드의 CPU, 메모리양과 현재 배포 후보 노드들의 CPU,메모리 유휴 자원을 보고 미달된 노드들은 제외시킴 (필터링)
  - 그 후 후보 파드의 CPU, 메모리양을 빼서 배포 후보 노드들의 랭킹을 매김
  - 가장 높은 랭킹의 노드에 파드를 배치시킴

## kubelet

- 노드의 선장
- kube-api-server가 스케쥴러에게 이 파드가 어디에 위치될지를 물어보고 난 후 kube-api-server는 스케쥴러가 정해준 노드의 kubelet에게 요청을 전달한다.

- 요청을 받은 kubelet은 컨테이너 런타임(여기선 도커)에게 이미지를 받아와서 컨테이너로 구동시킬 것을 명령한다.

- 일단 파드가 생성되면 kubelet은 파드를 지속적으로 감시하고 적절하게 kube-api-server에게 상황을 보고한다.

## kubeproxy

- 다른 노드에 존재하는 파드간의 통신은 **Pod Network**를 통해 이루어진다.

- **Pod Network** 내부 가상 네트워크이다.

- 다른 노드에 존재하는 파드간의 통신을 위해 서비스를 사용할 수 있는데, 서비스는 이 **Pod Network**에 포함되지 않는다.

- 서비스는 파드처럼 존재하는 컨테이너는 아니고 **actively listening process**이다. 즉, 서비스는 쿠버네티스 메모리에만 존재하는 가상의 컴포넌트다.

- kube-proxy는 모든 노드의 프로세스로 존재하며 새로운 서비스를 찾는 것이 목적이다.

- 새로운 서비스가 생기면 kube-proxy는 각각의 노드에 적절한 룰을 생성한다.

- 이 룰은 파드에 전송되에서 이러한 트래픽으로 트래픽을 포워드 하기 위함이다.

- kube-proxy는 IPTable을 만들고, 특정 파드의 IP를 서비스의 IP와 매핑시켜놓는다.

- 이렇게 하면 파드가 외부로 요청을 보낼때 proxy가 만든 IPTable에 있는 IP로 전송이 되고 이 IP는 서비스가 받아서, 노드로 전달하게 되며 전달받은 노드 역시 IPTable에 서비스의 IP로 들어온 요청을 노드 내의 파드의 IP로 연결시켜 놓는다.
