---
layout: post
title: 오브젝트 2장
subtitle: ''
categories: cs
tags: OOP
comments: false
---

## 오브젝트 2장

제 2장

## 객체지향 프로그래밍

- 객체지향 패러다임은 `클래스`가 아닌 `객체`에 초점을 맞춰야 한다.
- 훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.
- 훌륭한 클래스를 설계하기 위해서는 클래스의 경계를 구분 지어야 한다.
  - 왜 구분 지어야 할까?
    - 경계의 명확성이 객체의 자율성을 보장하기 때문
    - 프로그래머에게 구현의 자유를 제공하기 때문
- 객체는 **상태**와 **행동**을 갖고 스스로 판단하고 행동하는 **자율적인 존재**
- 협력을 위해 객체는 **메시지**를 통해 상호작용 한다.
- 수신된 메세지를 처리하기 위한 자신만의 방법을 **메서드**라고 부른다.
  - A 객체가 B 객체의 메서드를 호출한다. X
  - A 객체가 B 객체에게 메시지를 전송한다. O
  - B 객체는 A 객체로 부터 받은 메시지를 통해 **자율적**으로 자신이 사용할 메서드를 **결정**
- 상속은 코드를 재사용하기 위한 좋은 방법
- 부모 클래스와 다른 부분만 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍**(programming by difference)라고 부른다.
- 다형성은 일반적으로 추상클래스,인터페이스를 사용하여 구현할 수 있다.
  - 다형성을 이루는 핵심 기술은 오버라이딩과 오버로딩
- 객체지향 프로그래밍은 추상화를 통해 재사용 가능한 설계의 기반을 만들 수 있다.
- 추상화를 이용하면 설계를 유연하게 만들 수 있다.
- 추상 클래스와 인터페이스는 트레이드오프 관계
- 코드 재사용을 위해 일반적으로 상속보다는 **합성**이 더 좋은 방법이다.
- 왜 **합성**(composition)이 상속보다 더 선호될까?
- 상속의 두가지 문제 
  - 첫번째 문제는 **캡슐화**를 위반
    - 부모 클래스의 구현이 자식 클래스에게 노출
  - 두번째 문제는 **설계가 유연하지 못하다**
    - 부모,자식의 관계가 컴파일 시점에 결정되면서 실행 시점에 객체의 종류를 변경하는 것이 불가능
- 합성은 클래스 내부에 인스턴스 변수를 보유함으로써 상속의 두가지 문제를 해결
- 코드를 재사용하는 경우라면 일반적으로 **합성**을 사용하는 것이 맞지만, 다형성을 위해 인터페이스를 재사용 하는 경우라면 상속과 합성을 같이 쓰는 것이 적절
- 결국 상속과 합성은 상황에 맞게 적절하게 섞어서 써야함

## Reference

오브젝트 - 조영호