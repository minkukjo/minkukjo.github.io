---
layout: post
title: Sentry - 작성중
subtitle: ""
categories: cs
tags: Infra
comments: false
---

## Sentry란?

개발이 완료된 서버를 배포한 운영 상황에서 로깅과 모니터링의 중요성은 논란의 여지 없이 **매우 매우 매우** 중요하다.

만약 이러한 에러 로깅과 모니터링을 동시에 할 수 있는 도구가 있다고 하면 믿겠는가?

그것이 바로 **Sentry**이다!

## Sentry의 강점

**Sentry**는 실시간으로 프로그램 이슈를 트래킹하다가 에러가 발생하면 설정에 따라 특정 사용자나 그룹에 알림을 보낼 수도 있다.

만약 Slack이나 카카오 워크(깨알 홍보)같은 팀내 협업 도구를 사용한다면 해당 채팅방으로 알람을 쏴주는 것도 가능하다.

카카오에서는 이러한 시스템들이 잘 구축되어 있어서 Sentry가 해당 관리 서비스의 DSN만 명시해주면, 알아서 카카오톡에서 알람을 날려주는 Bot이 존재한다.

**Sentry**의 또 다른 강점은 Java, Golang, Node, Python 등 거의 모든 언어 플랫폼을 지원하며, Unreal Engine같은 게임 개발 도구까지도 지원된다.

즉, **방대한 플랫폼 지원이 Sentry의 또 다른 강점이기도 하다.**

## Springboot에 센트리 적용해보기

센트리 설정은 그렇게 어렵지 않다.

우선 예제를 보자.

스프링 부트 2.3.0으로 작성되었고 Kotlin으로 작성되었음을 미리 알린다.

```kotlin
@Configuration
class BeanConfig {
    @Bean
    fun sentryExceptionResolver(): HandlerExceptionResolver {
        return SentryExceptionResolver()
    }

    @Bean
    fun sentryServletContextInitializer(): ServletContextInitializer {
        return SentryServletContextInitializer()
    }
}
```

**HandlerExceptionResolver** 인터페이스를 구현하고 있는 것을 볼 수 있다.

**HandlerExceptionResolver**는 `DispatcherServlet` 이후 발생하는 모든 예외 상황을 처리하는 **Resolver**라고 보면 된다.

**ServletContextInitializer**을 처음 봐서 조금 조사를 해보았다.

```
 * This interface is designed to act in a similar way to
 * {@link ServletContainerInitializer}, but have a lifecycle that's managed by Spring and
 * not the Servlet container.
```

**ServletContextInitializer**를 열어보면 위와 같은 주석이 달려있는데, 대략 내용은 다음과 같다.

```
이 인터페이스는 ServletContainerInitializer과 비슷한 동작을 수행하기 위해 디자인되었지만,

서블릿 컨테이너가 아닌 스프링에 의해 관리되어지는 라이프 사이클을 갖고 있다.
```

여기서 알 수 있는 사실은 **ServletContainerInitializer**은 서블릿 컨테이너에 의해 관리되는 생명주기를 갖는 다는 것을 알 수 있다.

그도 그럴 것이 **ServletContainerInitializer**는 이름에서 보듯이 서블릿 컨테이너를 구동하는 인터페이스이다.

그래서 **startUp**이라는 메소드 하나만 갖는 것을 알 수 있다.

Spring MVC에서는 **ServletContainerInitializer**를 구현한 **SpringServletContainerInitializer**를 제공하고 있다는 사실을 잊지말자.

Sentry 공식문서를 살펴보면 스프링부트의 경우 **javax.servlet.ServletContainerInitializer**를 자동으로 로드하지 않는다고 한다.

그래서 Sentry가 HTTP 리퀘스트에 대한 정보를 수집하기 위한 리퀘스트 사이클을 가져올 수 없다는 것을 의미한다.

이를 위해 io.sentry.spring.SentryServletContextInitializer를 빈으로 등록해야한다고 적혀있다.

**io.sentry.spring.SentryServletContextInitializer**의 경우 이름에도 알 수 있다 싶이, **ServletContextInitializer**의 구현체이다.

**ServletContextInitializer**의 경우 

@Profile("!test")
@Configuration
class SentryConfig(
        @Value("\${config.sentry.dsn}") private val dsn: String
) {
    init {
        Sentry.init(dsn)
    }
}

## Reference

https://johnmarc.tistory.com/51

https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/

https://github.com/getsentry/sentry-java/blob/master/sentry-spring/src/main/java/io/sentry/spring/SentryServletContextInitializer.java

코드 출처 : PJ와 애런의 코드

